{"version":3,"file":"headless.mjs","sources":["../../../../src/utils/headless.ts"],"sourcesContent":["import { VNode, h, Teleport, Suspense, Comment, Fragment, Text, Slot } from 'vue'\n\ntype NodeAttributes = Record<string, any>\n\nconst toNode = (v: any, attrs: NodeAttributes): VNode | null => {\n  if (!v) { return null }\n\n  if (!('type' in v) || v.type === Text || typeof v === 'string') {\n    return h('div', attrs, v)\n  }\n\n  if (v.type === Comment) {\n    return v\n  }\n\n  if ('$el' in v) {\n    return toNode(v.$el, attrs)\n  }\n\n  if ((v.type as any) === Suspense) {\n    // Suspense is not supported, we just return default content. I'm not sure\n    // how to check if Suspense is ready to show default content instead of fallback.\n    // Since Suspense is still experimental let's just ignore it for now.\n    return h(v.ssContent, attrs) // TODO: Render decide when render fallback\n  }\n\n  if ((v.type as any) === Teleport) {\n    if (v.children === null) { return v }\n\n    const anchor = toNode(v.children[0], attrs)\n\n    if (anchor) {\n      v.children[0] = h(anchor, attrs)\n    }\n    return v\n  }\n\n  if (v.type === Fragment) {\n    if (v.children === null) { return v }\n    if (v.children.length === 1) { return h(Fragment, v.props, [toNode(v.children[0], attrs)]) }\n    return h('div', attrs, v)\n  }\n\n  if (typeof v.type.render === 'function') {\n    const component = h(v)\n\n    if (Array.isArray(component.children) && component.children.length > 1) {\n      return h('div', attrs, component.children)\n    }\n  }\n\n  return h(v, attrs)\n}\n\n/** Renders node, apply slot bind and attributes to actual HTML Node, not vue pseudo elements */\nexport const renderSlotNode = (slot: Slot | undefined, slotBind: any = {}, nodeAttributes: NodeAttributes = {}) => {\n  const children = slot?.(slotBind)\n\n  if (!children) { return null }\n\n  const nonCommentChildren = children.filter((v) => v.type !== Comment)\n\n  if (nonCommentChildren.length === 0) { return null }\n  if (nonCommentChildren.length === 1) { return toNode(nonCommentChildren[0], nodeAttributes) }\n\n  return h('div', nodeAttributes, children)\n}\n\nexport const renderSlotNodes = (slot: Slot | undefined, slotBind: any = {}, nodeAttributes: NodeAttributes = {}) => {\n  const children = slot?.(slotBind)\n\n  if (!children) { return null }\n\n  // Convert to Node first non-comment child or first child\n  return children.map((v) => toNode(v, nodeAttributes))\n}\n"],"names":[],"mappings":";AAIA,MAAM,SAAS,CAAC,GAAQ,UAAwC;AAC9D,MAAI,CAAC,GAAG;AAAS,WAAA;AAAA,EAAK;AAElB,MAAA,EAAE,UAAU,MAAM,EAAE,SAAS,QAAQ,OAAO,MAAM,UAAU;AACvD,WAAA,EAAE,OAAO,OAAO,CAAC;AAAA,EAC1B;AAEI,MAAA,EAAE,SAAS,SAAS;AACf,WAAA;AAAA,EACT;AAEA,MAAI,SAAS,GAAG;AACP,WAAA,OAAO,EAAE,KAAK,KAAK;AAAA,EAC5B;AAEK,MAAA,EAAE,SAAiB,UAAU;AAIzB,WAAA,EAAE,EAAE,WAAW,KAAK;AAAA,EAC7B;AAEK,MAAA,EAAE,SAAiB,UAAU;AAC5B,QAAA,EAAE,aAAa,MAAM;AAAS,aAAA;AAAA,IAAE;AAEpC,UAAM,SAAS,OAAO,EAAE,SAAS,CAAC,GAAG,KAAK;AAE1C,QAAI,QAAQ;AACV,QAAE,SAAS,CAAC,IAAI,EAAE,QAAQ,KAAK;AAAA,IACjC;AACO,WAAA;AAAA,EACT;AAEI,MAAA,EAAE,SAAS,UAAU;AACnB,QAAA,EAAE,aAAa,MAAM;AAAS,aAAA;AAAA,IAAE;AAChC,QAAA,EAAE,SAAS,WAAW,GAAG;AAAE,aAAO,EAAE,UAAU,EAAE,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IAAE;AACpF,WAAA,EAAE,OAAO,OAAO,CAAC;AAAA,EAC1B;AAEA,MAAI,OAAO,EAAE,KAAK,WAAW,YAAY;AACjC,UAAA,YAAY,EAAE,CAAC;AAEjB,QAAA,MAAM,QAAQ,UAAU,QAAQ,KAAK,UAAU,SAAS,SAAS,GAAG;AACtE,aAAO,EAAE,OAAO,OAAO,UAAU,QAAQ;AAAA,IAC3C;AAAA,EACF;AAEO,SAAA,EAAE,GAAG,KAAK;AACnB;AAGa,MAAA,iBAAiB,CAAC,MAAwB,WAAgB,CAAA,GAAI,iBAAiC,CAAA,MAAO;AAC3G,QAAA,WAAW,6BAAO;AAExB,MAAI,CAAC,UAAU;AAAS,WAAA;AAAA,EAAK;AAE7B,QAAM,qBAAqB,SAAS,OAAO,CAAC,MAAM,EAAE,SAAS,OAAO;AAEhE,MAAA,mBAAmB,WAAW,GAAG;AAAS,WAAA;AAAA,EAAK;AAC/C,MAAA,mBAAmB,WAAW,GAAG;AAAE,WAAO,OAAO,mBAAmB,CAAC,GAAG,cAAc;AAAA,EAAE;AAErF,SAAA,EAAE,OAAO,gBAAgB,QAAQ;AAC1C;AAEa,MAAA,kBAAkB,CAAC,MAAwB,WAAgB,CAAA,GAAI,iBAAiC,CAAA,MAAO;AAC5G,QAAA,WAAW,6BAAO;AAExB,MAAI,CAAC,UAAU;AAAS,WAAA;AAAA,EAAK;AAG7B,SAAO,SAAS,IAAI,CAAC,MAAM,OAAO,GAAG,cAAc,CAAC;AACtD;"}