{"version":3,"file":"time-text-parser.mjs","sources":["../../../../../../src/components/va-time-input/hooks/time-text-parser.ts"],"sourcesContent":["import { Ref, ref } from 'vue'\n\nconst parse = (text: string) => {\n  const m = text.match(/[0-9]{1,2}/g)\n\n  if (!m) { return [] }\n\n  return m.map((s) => Number(s))\n}\n\nconst parsePeriod = (text: string) => {\n  const m = text.match(/pm|am/i)\n\n  if (!m) { return null }\n\n  return Number(m[0].toLowerCase() === 'pm')\n}\n\nconst defaultParseDateFunction = (text: string) => {\n  const d = new Date()\n\n  const [h, m, s] = parse(text)\n  const period = parsePeriod(text)\n\n  if (!h) { return null }\n\n  const is12format = period !== null && h <= 12\n  const isPM = is12format && !!period\n  // Switch 12 to 0, because of 12h format\n  const fh = is12format ? (h === 12 ? 0 : h) : h\n\n  d.setHours(Math.min((fh || 0), is12format ? 12 : 24) + (isPM ? 12 : 0))\n  d.setMinutes(Math.min(m || 0, 60))\n  d.setSeconds(Math.min(s || 0, 60))\n\n  return d\n}\n\nexport const useTimeParser = (props: {\n  parse?: (input: string, isValidRef?: Ref<boolean>) => Date,\n}) => {\n  // const isTextIsMultipleDates = (text: string) => text.includes(props.delimiter)\n  // const isTextIsDateRange = (text: string) => text.includes(props.rangeDelimiter)\n\n  const getParseDateFn = () => props.parse || defaultParseDateFunction\n\n  const isValid = ref(true)\n\n  const parseDate = (text: string) => {\n    const parse = getParseDateFn()\n\n    const result = parse(text)\n\n    if (!result) { isValid.value = false }\n\n    return result\n  }\n\n  const parse = (text: string) => {\n    isValid.value = true\n\n    // if (props.parse) {\n    //   return props.parse(text, isValid)\n    // }\n\n    // if (isTextIsMultipleDates(text)) {\n    //   return text.split(props.delimiter).map((dateText) => parseDate(dateText))\n    // }\n\n    // if (isTextIsDateRange(text)) {\n    //   const [start, end] = text.split(props.rangeDelimiter).map((dateText) => parseDate(dateText))\n    //   return { start, end }\n    // }\n\n    return parseDate(text)\n  }\n\n  return {\n    parse,\n    isValid,\n  }\n}\n"],"names":["parse"],"mappings":";AAEA,MAAM,QAAQ,CAAC,SAAiB;AACxB,QAAA,IAAI,KAAK,MAAM,aAAa;AAElC,MAAI,CAAC,GAAG;AAAE,WAAO;EAAG;AAEpB,SAAO,EAAE,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC;AAC/B;AAEA,MAAM,cAAc,CAAC,SAAiB;AAC9B,QAAA,IAAI,KAAK,MAAM,QAAQ;AAE7B,MAAI,CAAC,GAAG;AAAS,WAAA;AAAA,EAAK;AAEtB,SAAO,OAAO,EAAE,CAAC,EAAE,YAAA,MAAkB,IAAI;AAC3C;AAEA,MAAM,2BAA2B,CAAC,SAAiB;AAC3C,QAAA,wBAAQ;AAEd,QAAM,CAAC,GAAG,GAAG,CAAC,IAAI,MAAM,IAAI;AACtB,QAAA,SAAS,YAAY,IAAI;AAE/B,MAAI,CAAC,GAAG;AAAS,WAAA;AAAA,EAAK;AAEhB,QAAA,aAAa,WAAW,QAAQ,KAAK;AACrC,QAAA,OAAO,cAAc,CAAC,CAAC;AAE7B,QAAM,KAAK,aAAc,MAAM,KAAK,IAAI,IAAK;AAE3C,IAAA,SAAS,KAAK,IAAK,MAAM,GAAI,aAAa,KAAK,EAAE,KAAK,OAAO,KAAK,EAAE;AACtE,IAAE,WAAW,KAAK,IAAI,KAAK,GAAG,EAAE,CAAC;AACjC,IAAE,WAAW,KAAK,IAAI,KAAK,GAAG,EAAE,CAAC;AAE1B,SAAA;AACT;AAEa,MAAA,gBAAgB,CAAC,UAExB;AAIE,QAAA,iBAAiB,MAAM,MAAM,SAAS;AAEtC,QAAA,UAAU,IAAI,IAAI;AAElB,QAAA,YAAY,CAAC,SAAiB;AAClC,UAAMA,SAAQ;AAER,UAAA,SAASA,OAAM,IAAI;AAEzB,QAAI,CAAC,QAAQ;AAAE,cAAQ,QAAQ;AAAA,IAAM;AAE9B,WAAA;AAAA,EAAA;AAGHA,QAAAA,SAAQ,CAAC,SAAiB;AAC9B,YAAQ,QAAQ;AAehB,WAAO,UAAU,IAAI;AAAA,EAAA;AAGhB,SAAA;AAAA,IACL,OAAAA;AAAAA,IACA;AAAA,EAAA;AAEJ;"}