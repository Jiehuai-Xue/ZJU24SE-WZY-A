{"version":3,"file":"input-text-parser.mjs","sources":["../../../../../../src/components/va-date-input/hooks/input-text-parser.ts"],"sourcesContent":["import { DateInputRange, DateInputValue } from './../types'\nimport { Ref, ref } from 'vue'\nimport isDate from 'lodash/isDate.js'\n\nexport const defaultParseDateFunction = (text: string) => new Date(Date.parse(text))\n\nconst isValidDate = (d: Date) => isDate(d) && !isNaN(d.getTime())\n\nexport const useDateParser = (props: {\n  parse?: (input: string, isValidRef?: Ref<boolean>) => DateInputValue,\n  parseDate?: (input: string) => Date,\n  delimiter: string,\n  rangeDelimiter: string,\n}) => {\n  const isMultipleDates = (text: string) => {\n    const dates = text.split(props.delimiter)\n\n    if (dates.length < 2) { return false }\n\n    // May be format like 'Mon, 31 Dec 2018 23:00:00 GMT' or '12, 31, 2018'\n    return dates.every((date) => {\n      const parsedDate = (props.parseDate || defaultParseDateFunction)(date)\n      return isValidDate(parsedDate)\n    })\n  }\n  const isRange = (text: string) => text.includes(props.rangeDelimiter)\n\n  const isValid = ref(true)\n\n  const parseDate = (text: string) => {\n    /**\n     * for american locales 01.02.2000 will be parsed as 02 Jan 2000 (not 01 Feb 2000)\n     * iso 8601 (YYYY-MM-DD) solves this problem\n     */\n    const splitDate = text.split('.')\n    const valueToParse = splitDate?.length === 3 ? splitDate.reverse().join('-') : text\n\n    const date = (props.parseDate || defaultParseDateFunction)(valueToParse)\n\n    isValid.value = isValidDate(date)\n\n    return date\n  }\n\n  const parseDateInputValue = (text: string) => {\n    isValid.value = true\n\n    if (props.parse) {\n      return props.parse(text, isValid)\n    }\n\n    if (isMultipleDates(text)) {\n      return text.split(props.delimiter).map(parseDate)\n    }\n\n    if (isRange(text)) {\n      const [start, end] = text.split(props.rangeDelimiter).map(parseDate)\n      return { start, end }\n    }\n\n    return parseDate(text)\n  }\n\n  return {\n    parseDateInputValue,\n    isValid,\n  }\n}\n"],"names":[],"mappings":";;AAIa,MAAA,2BAA2B,CAAC,SAAiB,IAAI,KAAK,KAAK,MAAM,IAAI,CAAC;AAEnF,MAAM,cAAc,CAAC,MAAY,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,QAAA,CAAS;AAEnD,MAAA,gBAAgB,CAAC,UAKxB;AACE,QAAA,kBAAkB,CAAC,SAAiB;AACxC,UAAM,QAAQ,KAAK,MAAM,MAAM,SAAS;AAEpC,QAAA,MAAM,SAAS,GAAG;AAAS,aAAA;AAAA,IAAM;AAG9B,WAAA,MAAM,MAAM,CAAC,SAAS;AAC3B,YAAM,cAAc,MAAM,aAAa,0BAA0B,IAAI;AACrE,aAAO,YAAY,UAAU;AAAA,IAAA,CAC9B;AAAA,EAAA;AAEH,QAAM,UAAU,CAAC,SAAiB,KAAK,SAAS,MAAM,cAAc;AAE9D,QAAA,UAAU,IAAI,IAAI;AAElB,QAAA,YAAY,CAAC,SAAiB;AAK5B,UAAA,YAAY,KAAK,MAAM,GAAG;AAC1B,UAAA,gBAAe,uCAAW,YAAW,IAAI,UAAU,QAAQ,EAAE,KAAK,GAAG,IAAI;AAE/E,UAAM,QAAQ,MAAM,aAAa,0BAA0B,YAAY;AAE/D,YAAA,QAAQ,YAAY,IAAI;AAEzB,WAAA;AAAA,EAAA;AAGH,QAAA,sBAAsB,CAAC,SAAiB;AAC5C,YAAQ,QAAQ;AAEhB,QAAI,MAAM,OAAO;AACR,aAAA,MAAM,MAAM,MAAM,OAAO;AAAA,IAClC;AAEI,QAAA,gBAAgB,IAAI,GAAG;AACzB,aAAO,KAAK,MAAM,MAAM,SAAS,EAAE,IAAI,SAAS;AAAA,IAClD;AAEI,QAAA,QAAQ,IAAI,GAAG;AACX,YAAA,CAAC,OAAO,GAAG,IAAI,KAAK,MAAM,MAAM,cAAc,EAAE,IAAI,SAAS;AAC5D,aAAA,EAAE,OAAO;IAClB;AAEA,WAAO,UAAU,IAAI;AAAA,EAAA;AAGhB,SAAA;AAAA,IACL;AAAA,IACA;AAAA,EAAA;AAEJ;"}