import { defineComponent, shallowRef, ref, toRefs, watch, computed, toRef, useSlots, useAttrs, openBlock, createBlock, unref, mergeProps, isRef, withCtx, renderSlot, normalizeProps, guardReactiveProps, createVNode, toHandlers, createSlots, withModifiers, withKeys, createCommentVNode, renderList, nextTick } from "vue";
import { o as omit } from "../../../vendor.mjs";
import { u as useRangeModelValueGuard } from "./hooks/range-model-value-guard.mjs";
import { u as useDateParser } from "./hooks/input-text-parser.mjs";
import { u as useDateInputModelValue } from "./hooks/model-value.mjs";
import { i as isRange, a as isDates, b as isSingleDate } from "../va-date-picker/utils/date-utils.mjs";
import { V as VaDropdown } from "../va-dropdown/index.mjs";
import { _ as _sfc_main$1 } from "../va-date-picker/VaDatePicker.vue_vue_type_script_setup_true_lang.mjs";
import { V as VaInputWrapper } from "../va-input-wrapper/index.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { u as unwrapEl } from "../../utils/unwrapEl.mjs";
import { u as useDropdownableProps, a as useDropdownableEmits, b as useDropdownable } from "../../composables/useDropdownable.mjs";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.mjs";
import { e as extractComponentProps, a as extractComponentEmits } from "../../utils/component-options/extract-component-options.mjs";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.mjs";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { a as useFocusEmits, u as useFocus } from "../../composables/useFocus.mjs";
import { a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useTrapFocus } from "../../composables/useTrapFocus.mjs";
import { u as useFocusDeep } from "../../composables/useFocusDeep.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
const VaInputWrapperPropsDeclaration = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const VaDatePickerPropsDeclaration = extractComponentProps(_sfc_main$1);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDateInput",
    inheritAttrs: false
  },
  __name: "VaDateInput",
  props: {
    ...useDropdownableProps,
    ...useClearableProps,
    ...VaInputWrapperPropsDeclaration,
    ...VaDatePickerPropsDeclaration,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    /** Force model value to string instead of date */
    formatValue: { type: Function },
    parse: { type: Function },
    parseDate: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" },
    ariaResetLabel: { type: String, default: "$t:resetDate" },
    ariaSelectedDateLabel: { type: String, default: "$t:selectedDate" }
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_sfc_main$1),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:text"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef();
    const datePicker = ref();
    const { resetOnClose } = toRefs(props);
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const trapFocus = () => {
      const el = unwrapEl(datePicker.value);
      if (!el) {
        freeFocus();
        return;
      }
      trapFocusIn(el);
    };
    watch([datePicker], () => {
      trapFocus();
    });
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => {
        if (Array.isArray(valueComputed.value)) {
          return false;
        }
        if (isRange(valueComputed.value) && valueComputed.value.end === null) {
          return false;
        }
        return true;
      })
    });
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const { isFocused: isInputFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isPickerFocused = useFocusDeep(datePicker);
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      if (value === null || value === void 0) {
        return "";
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }, got " + typeof value);
    };
    const {
      text,
      normalized: valueWithoutText
    } = useDateInputModelValue(valueComputed, toRef(props, "mode"), parseDateInputValue, modelValueToString, props.formatValue);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      isDirty,
      isTouched,
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      validate,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    watch(isOpenSync, (isOpen) => {
      if (!isOpen) {
        isTouched.value = true;
      }
    });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const slots = useSlots();
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: iconTabindexComputed.value === 0 ? "button" : "none",
      ariaHidden: iconTabindexComputed.value === -1,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperPropsDeclaration);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isInputFocused.value || isPickerFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      placeholder: props.placeholder,
      value: valueText.value,
      ariaLabel: props.label || tp(props.ariaSelectedDateLabel),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "enter", "space"]
    }));
    const inputWrapperProps = computedInputWrapperProps;
    const inputListeners = computedInputListeners;
    const datePickerProps = filterComponentProps(VaDatePickerPropsDeclaration);
    __expose({
      valueText,
      valueWithoutText,
      valueDate: valueWithoutText,
      focus,
      blur,
      reset,
      validate,
      showDropdown,
      hideAndFocus,
      toggleDropdown,
      focusDatePicker,
      isDirty,
      isTouched
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps({
        modelValue: unref(isOpenSync),
        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => isRef(isOpenSync) ? isOpenSync.value = $event : null),
        class: ["va-date-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value, {
        onOpen: focusDatePicker,
        role: "none"
      }), {
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: valueText.value, inputAttributes: inputAttributesComputed.value, inputWrapperProps: unref(inputWrapperProps), inputListeners: unref(inputListeners) })), () => [
            createVNode(unref(VaInputWrapper), mergeProps({
              class: "va-date-input__anchor",
              style: cursorStyleComputed.value
            }, unref(inputWrapperProps), toHandlers(unref(inputListeners)), {
              "model-value": valueText.value,
              onChange: onInputTextChanged
            }), createSlots({
              icon: withCtx(() => [
                unref(canBeCleared) ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                  key: 0,
                  "aria-label": unref(tp)(_ctx.$props.ariaResetLabel)
                }, { ...iconProps.value, ...unref(clearIconProps) }, {
                  onClick: withModifiers(reset, ["stop"]),
                  onKeydown: [
                    withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                    withKeys(withModifiers(reset, ["stop"]), ["space"])
                  ]
                }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
                !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                  key: 1,
                  "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, [
              renderList(filterSlots.value, (name) => {
                return {
                  name,
                  fn: withCtx((slotScope) => [
                    renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                  ])
                };
              }),
              _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
                name: "prependInner",
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
                  _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                    key: 0,
                    "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                  }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
                ]),
                key: "0"
              } : void 0
            ]), 1040, ["style", "model-value"])
          ])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            class: "va-date-input__dropdown-content",
            onKeydown: _cache[8] || (_cache[8] = withKeys(($event) => unref(focus)(), ["esc"])),
            role: "dialog"
          }, {
            default: withCtx(() => [
              createVNode(_sfc_main$1, mergeProps({
                ref_key: "datePicker",
                ref: datePicker
              }, unref(datePickerProps), {
                modelValue: unref(valueWithoutText),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueWithoutText) ? valueWithoutText.value = $event : null),
                "onClick:day": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:day", $event)),
                "onClick:month": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:month", $event)),
                "onClick:year": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:year", $event)),
                "onHover:day": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("hover:day", $event)),
                "onHover:month": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:month", $event)),
                "onHover:year": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:year", $event)),
                "onUpdate:view": _cache[7] || (_cache[7] = ($event) => {
                  _ctx.$nextTick(() => trapFocus());
                  _ctx.$emit("update:view", $event);
                })
              }), createSlots({ _: 2 }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((bind) => [
                      renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                    ])
                  };
                })
              ]), 1040, ["modelValue"])
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaDateInput.vue_vue_type_script_setup_true_lang.mjs.map
