import { defineComponent, shallowRef, ref, onMounted, computed, watch, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, renderSlot, normalizeProps, guardReactiveProps, withModifiers, createVNode } from "vue";
import { b as clamp, e as isNumber, f as isString } from "../../../vendor.mjs";
import { u as useSplitDraggerProps, a as useSplitDragger } from "./useSplitDragger.mjs";
import { w as warn } from "../../utils/console.mjs";
import { V as VaDivider } from "../va-divider/index.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useStatefulProps, a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useResizeObserver } from "../../composables/useResizeObserver.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
const _hoisted_1 = ["aria-label"];
const _hoisted_2 = { class: "va-split__dragger" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSplit"
  },
  __name: "VaSplit",
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v) => v <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 },
    ariaLabel: { type: String, default: "$t:splitPanels" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a;
      const { width, height } = ((_a = splitPanelsContainer.value) == null ? void 0 : _a.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber(v)) {
        return v;
      }
      v.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v) => {
      if (v === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString(v) || isNumber(v)) {
        minPercents = convertToPercents(v, "min");
      }
      if (Array.isArray(v)) {
        minPercents = convertToPercents(v[0], "min");
        maxPercents = convertToPercents(v[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents ?? 0, max: maxPercents ?? 100 };
    };
    const startPanelMinMax = computed(() => getPanelMinMax(props.limits[0]) ?? { min: 0, max: 100 });
    const endPanelMinMax = computed(() => getPanelMinMax(props.limits[1]) ?? { min: 0, max: 100 });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > Number(props.snappingRange);
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v) => {
      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v;
    }, { immediate: true });
    watch(currentSplitterPosition, (v) => {
      splitterPosition.value = v;
    });
    watch(isDragging, (v) => {
      if (!v) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    const { t, tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        ref_key: "splitPanelsContainer",
        ref: splitPanelsContainer,
        class: normalizeClass(["va-split", unref(classComputed)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        createElementVNode("div", {
          class: "va-split__panel",
          style: normalizeStyle(getPanelStyle("start"))
        }, [
          renderSlot(_ctx.$slots, "start", normalizeProps(guardReactiveProps({ containerSize: containerSize.value })))
        ], 4),
        createElementVNode("div", _hoisted_2, [
          createElementVNode("div", {
            class: "va-split__dragger__overlay",
            style: normalizeStyle(draggerStyleComputed.value),
            onMousedown: _cache[0] || (_cache[0] = withModifiers(
              //@ts-ignore
              (...args) => unref(startDragging) && unref(startDragging)(...args),
              ["prevent"]
            )),
            onTouchstart: _cache[1] || (_cache[1] = withModifiers(
              //@ts-ignore
              (...args) => unref(startDragging) && unref(startDragging)(...args),
              ["prevent"]
            )),
            onDblclick: withModifiers(maximizePanel, ["prevent"]),
            onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["prevent"])),
            onDragstart: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            renderSlot(_ctx.$slots, "grabber", {}, () => [
              createVNode(unref(VaDivider), {
                class: "va-split__dragger__default",
                vertical: !_ctx.$props.vertical
              }, null, 8, ["vertical"])
            ])
          ], 36)
        ]),
        createElementVNode("div", {
          class: "va-split__panel",
          style: normalizeStyle(getPanelStyle("end"))
        }, [
          renderSlot(_ctx.$slots, "end", normalizeProps(guardReactiveProps({ containerSize: containerSize.value })))
        ], 4)
      ], 10, _hoisted_1);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSplit.vue_vue_type_script_setup_true_lang.mjs.map
