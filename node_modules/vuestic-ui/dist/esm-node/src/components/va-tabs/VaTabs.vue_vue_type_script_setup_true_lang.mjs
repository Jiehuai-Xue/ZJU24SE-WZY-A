import { defineComponent, shallowRef, ref, reactive, computed, unref, provide, watch, onMounted, openBlock, createElementBlock, normalizeClass, createElementVNode, createBlock, createCommentVNode, normalizeStyle, createVNode, withCtx, renderSlot } from "vue";
import { T as TabsViewKey } from "./types.mjs";
import { V as VaButton } from "../va-button/index.mjs";
import { _ as _sfc_main$1 } from "../va-config/VaConfig.vue_vue_type_script_setup_true_lang.mjs";
import { u as useStatefulProps, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
import { u as useResizeObserver } from "../../composables/useResizeObserver.mjs";
const _hoisted_1 = ["aria-disabled"];
const _hoisted_2 = /* @__PURE__ */ createElementVNode("div", { class: "va-tabs__slider" }, null, -1);
const _hoisted_3 = [
  _hoisted_2
];
const _hoisted_4 = { class: "va-tabs__tabs-items" };
const _hoisted_5 = { class: "va-tabs__content" };
const getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTabs"
  },
  __name: "VaTabs",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" },
    ariaMoveRightLabel: { type: String, default: "$t:movePaginationLeft" },
    ariaMoveLeftLabel: { type: String, default: "$t:movePaginationRight" }
  },
  emits: ["update:modelValue", "click:next", "click:prev"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
        position: props.hidePagination ? "unset" : "absolute"
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (!showPagination.value) {
        tabsContentOffset.value = 0;
        return;
      }
      if (leftSidePosition - tabsContentOffset.value >= 0 && rightSidePosition - tabsContentOffset.value <= containerClientWidth) {
        return;
      }
      if (leftSidePosition - tabsContentOffset.value < 0) {
        tabsContentOffset.value = leftSidePosition;
        return;
      }
      if (rightSidePosition - tabsContentOffset.value > containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
        return;
      }
      tabsContentOffset.value = 0;
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a;
        tab.updateSidePositions();
        const isTabSelected = (((_a = tab.name) == null ? void 0 : _a.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      requestAnimationFrame(() => {
        showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
      });
    };
    const movePaginationLeft = () => {
      var _a, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const currentTabLeftSidePosition = unref((_a = tabsList.value[i]) == null ? void 0 : _a.leftSidePosition);
        const nextTabLeftSidePosition = unref((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
        if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
          offsetToSet = currentTabLeftSidePosition;
          break;
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const rightSidePosition2 = unref(tabsList.value[i].rightSidePosition);
        if (rightSidePosition2 > containerRightSide) {
          offsetToSet = unref(tabsList.value[i].leftSidePosition);
          if (tabsContentOffset.value < offsetToSet) {
            break;
          }
        }
      }
      const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a = container.value) == null ? void 0 : _a.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const selectTab = (tab) => {
      var _a;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a = tab.name) == null ? void 0 : _a.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a = tab.name) == null ? void 0 : _a.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a;
        tabListItem.id = ((_a = tabListItem.name) == null ? void 0 : _a.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper], updatePagination);
    useResizeObserver([container], updateTabsState);
    onMounted(() => {
      requestAnimationFrame(() => {
        includeAnimation();
      });
    });
    __expose({
      selectTab,
      moveToTab,
      movePaginationLeft,
      movePaginationRight
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-tabs", computedTabsClass.value])
      }, [
        createElementVNode("div", {
          ref_key: "wrapper",
          ref: wrapper,
          class: "va-tabs__wrapper",
          role: "tablist",
          "aria-disabled": _ctx.$props.disabled
        }, [
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock(), createBlock(unref(VaButton), {
            key: 0,
            class: "va-tabs__pagination",
            "aria-label": unref(tp)(_ctx.$props.ariaMoveLeftLabel),
            size: "medium",
            disabled: disablePaginationLeft.value,
            color: __props.color,
            preset: "secondary",
            icon: _ctx.$props.prevIcon,
            onClick: movePaginationLeft
          }, null, 8, ["aria-label", "disabled", "color", "icon"])) : createCommentVNode("", true),
          createElementVNode("div", {
            ref_key: "container",
            ref: container,
            class: normalizeClass(["va-tabs__container", computedClass.value])
          }, [
            createElementVNode("div", {
              ref_key: "tabs",
              ref: tabs,
              class: "va-tabs__tabs",
              style: normalizeStyle(paginationControlledStyles.value)
            }, [
              createElementVNode("div", {
                class: "va-tabs__slider-wrapper",
                "aria-hidden": "true",
                style: normalizeStyle(sliderStyles.value)
              }, _hoisted_3, 4),
              createVNode(unref(_sfc_main$1), { components: tabConfig }, {
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_4, [
                    renderSlot(_ctx.$slots, "tabs")
                  ])
                ]),
                _: 3
              }, 8, ["components"])
            ], 4)
          ], 2),
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock(), createBlock(unref(VaButton), {
            key: 1,
            class: "va-tabs__pagination",
            "aria-label": unref(tp)(_ctx.$props.ariaMoveRightLabel),
            size: "medium",
            color: __props.color,
            disabled: disablePaginationRight.value,
            preset: "secondary",
            icon: _ctx.$props.nextIcon,
            onClick: movePaginationRight
          }, null, 8, ["aria-label", "color", "disabled", "icon"])) : createCommentVNode("", true)
        ], 8, _hoisted_1),
        createElementVNode("div", _hoisted_5, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 2);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaTabs.vue_vue_type_script_setup_true_lang.mjs.map
