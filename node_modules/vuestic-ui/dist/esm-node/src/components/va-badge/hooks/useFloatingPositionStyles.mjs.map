{"version":3,"file":"useFloatingPositionStyles.mjs","sources":["../../../../../../src/components/va-badge/hooks/useFloatingPositionStyles.ts"],"sourcesContent":["import type { ExtractPropTypes, PropType, Ref } from 'vue'\n\nimport type { PlacementWithAlias } from '../../../composables'\nimport type { BadgeOffsetProp } from '../types'\n\nimport { computed } from 'vue'\n\nimport { usePlacementAliases, placementsPositionsWithAliases, useParsableMeasure } from '../../../composables'\n\nconst { isParsableMeasure, parseSizeValue } = useParsableMeasure()\n\nexport const useFloatingPositionProps = {\n  overlap: { type: Boolean, default: false },\n  placement: {\n    type: String as PropType<PlacementWithAlias>,\n    default: 'top-end',\n    validator: (position: PlacementWithAlias) => placementsPositionsWithAliases.includes(position),\n  },\n  offset: {\n    type: [Number, String, Array] as PropType<BadgeOffsetProp>,\n    default: 0,\n    validator: (value: keyof BadgeOffsetProp) => {\n      if (Array.isArray(value)) {\n        return value.every(isParsableMeasure)\n      }\n\n      if (typeof value === 'string') {\n        return isParsableMeasure(value)\n      }\n\n      return !isNaN(value)\n    },\n  },\n}\n\nexport const useFloatingPosition = (\n  props: ExtractPropTypes<typeof useFloatingPositionProps>,\n  floating: Ref<boolean>,\n) => {\n  if (!floating.value) { return {} }\n\n  const { position, align } = usePlacementAliases(props)\n\n  const alignmentShiftComputed = computed(() => {\n    const alignOptions = {\n      start: props.overlap ? '-50%' : '-100%',\n      center: '-50%',\n      end: props.overlap ? '-50%' : '0%',\n    }\n\n    return alignOptions[align.value]\n  })\n\n  const offsetMarginComputed = computed(() => {\n    if (!props.offset) { return {} }\n\n    const mainAxis = ['left', 'right'].includes(position.value) ? 'top' : 'left'\n    const crossAxis = mainAxis === 'top' ? 'left' : 'top'\n\n    if (Array.isArray(props.offset)) {\n      const [x, y] = props.offset.map(parseSizeValue)\n\n      return {\n        [`margin-${mainAxis}`]: `${x}px`,\n        [`margin-${crossAxis}`]: `${y}px`,\n      }\n    }\n\n    const offset = parseSizeValue(props.offset)\n\n    return {\n      [`margin-${crossAxis}`]: `${offset}px`,\n    }\n  })\n\n  const alignmentComputed = computed(() => {\n    const mainAxis = ['left', 'right'].includes(position.value) ? 'top' : 'left'\n    const crossAxis = mainAxis === 'top' ? 'left' : 'top'\n    let shiftValue = '0%'\n\n    if (crossAxis === 'top' && position.value === 'bottom') {\n      shiftValue = '100%'\n    }\n\n    if (crossAxis === 'left' && position.value === 'right') {\n      shiftValue = '100%'\n    }\n\n    const alignmentOptions = {\n      start: { [mainAxis]: '0%', [crossAxis]: shiftValue },\n      center: { [mainAxis]: '50%', [crossAxis]: shiftValue },\n      end: { [mainAxis]: '100%', [crossAxis]: shiftValue },\n    }\n\n    return alignmentOptions[align.value]\n  })\n\n  const transformComputed = computed(() => {\n    const coords = {\n      top: {\n        x: alignmentShiftComputed.value,\n        y: props.overlap ? '-50%' : '-100%',\n      },\n      bottom: {\n        x: alignmentShiftComputed.value,\n        y: props.overlap ? '-50%' : '0%',\n      },\n      left: {\n        x: props.overlap ? '-50%' : '-100%',\n        y: alignmentShiftComputed.value,\n      },\n      right: {\n        x: props.overlap ? '-50%' : '0%',\n        y: alignmentShiftComputed.value,\n      },\n    }\n\n    const { x, y } = coords[position.value]\n\n    return { transform: `translate(${x}, ${y})` }\n  })\n\n  return computed(() => ({\n    ...alignmentComputed.value,\n    ...transformComputed.value,\n    ...offsetMarginComputed.value,\n  }))\n}\n"],"names":[],"mappings":"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"}