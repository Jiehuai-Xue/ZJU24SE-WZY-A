import { defineComponent, watch, computed, ref, nextTick, h, Teleport, Fragment } from "vue";
import { p as pick } from "../../../vendor.mjs";
import { a as renderSlotNode } from "../../utils/headless.mjs";
import { u as useNavigation } from "./hooks/useDropdownNavigation.mjs";
import { u as useAnchorSelector } from "./hooks/useAnchorSelector.mjs";
import { u as useCursorAnchor } from "./hooks/useCursorAnchor.mjs";
import { u as useDropdown } from "./hooks/useDropdown.mjs";
import { w as warn } from "../../utils/console.mjs";
import { u as useFocusOutside } from "../../composables/useFocusOutside.mjs";
import { u as useTeleported } from "../../composables/useTeleported.mjs";
import { u as useZIndex } from "../../composables/useZIndex.mjs";
import { f as focusFirstFocusableChild } from "../../utils/focus.mjs";
import { u as unwrapEl } from "../../utils/unwrapEl.mjs";
import { a as usePlacementAliasesProps } from "../../composables/usePlacementAliases.mjs";
import { c as createStatefulProps, a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useHTMLElementSelector } from "../../composables/useHTMLElementSelector.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useClickOutside } from "../../composables/useClickOutside.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useIsMounted } from "../../composables/useIsMounted.mjs";
import { u as useHTMLElement } from "../../composables/useHTMLElement.mjs";
const _sfc_main = defineComponent({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(true),
    modelValue: { type: Boolean, default: false },
    anchor: { type: [String, Object], default: void 0 },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: [String, Array],
      default: () => ["click", "space", "enter", "arrow-down", "arrow-up"]
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: [Number, String], default: 30 },
    hoverOutTimeout: { type: [Number, String], default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: [Boolean, Object], default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: true },
    ariaLabel: { type: String, default: "$t:toggleDropdown" },
    role: { type: String, default: "button" },
    contentClass: { type: String, default: "" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue");
    watch(valueComputed, (isOpened) => {
      if (isOpened) {
        emit("open");
      } else {
        emit("close");
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef } = useAnchorSelector(props);
    const cursorAnchor = useCursorAnchor(anchorRef, computed(() => Boolean(props.cursor)));
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref("body"));
    const target = useHTMLElementSelector(computed(() => props.target));
    const teleport = useHTMLElementSelector(computed(() => props.teleport));
    const anchorClass = useBem("va-dropdown", () => pick(props, ["disabled"]));
    const teleportTarget = computed(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      if (anchorRef.value) {
        const root = anchorRef.value.getRootNode();
        if (root instanceof ShadowRoot) {
          const el = [...root.children].find((c) => c.tagName !== "STYLE");
          if (el) {
            return el;
          }
        }
      }
      return body.value;
    });
    const showFloating = computed(() => isMounted.value && valueComputed.value);
    useNavigation(
      valueComputed,
      anchorRef,
      floating,
      props
    );
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close) {
        valueComputed.value = false;
      }
    };
    useClickOutside([anchorRef, floating], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed(() => {
      if (typeof props.cursor === "object") {
        return props.cursor;
      }
      return props.cursor ? cursorAnchor.value : anchorRef.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed(() => ({
        placement: props.placement,
        offset: props.offset,
        autoPlacement: props.autoPlacement,
        stickToEdges: props.stickToEdges,
        keepAnchorWidth: props.keepAnchorWidth,
        verticalScrollOnOverflow: props.verticalScrollOnOverflow
      }))
    );
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const {
      zIndex
    } = useZIndex(valueComputed);
    watch(valueComputed, (isOpened) => {
      if (!props.keyboardNavigation) {
        return;
      }
      if (isOpened) {
        nextTick(() => {
          const el = unwrapEl(floating.value);
          if (!el) {
            return;
          }
          focusFirstFocusableChild(el);
        });
      } else {
        if (!anchorRef.value) {
          return;
        }
        focusFirstFocusableChild(anchorRef.value);
      }
    });
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchorRef,
      anchorClass,
      floating,
      floatingStyles,
      showFloating,
      teleportTarget,
      isMounted,
      valueComputed,
      hide,
      show,
      zIndex
    };
  },
  render() {
    const slotBind = {
      isOpened: this.valueComputed,
      hide: this.hide,
      show: this.show,
      toggle: () => this.valueComputed ? this.hide() : this.show(),
      getAnchorWidth: () => {
        var _a;
        return ((_a = this.anchorRef) == null ? void 0 : _a.offsetWidth) + "px";
      },
      getAnchorHeight: () => {
        var _a;
        return ((_a = this.anchorRef) == null ? void 0 : _a.offsetHeight) + "px";
      }
    };
    const floatingSlotNode = this.showFloating && renderSlotNode(this.$slots.default, slotBind, {
      ref: "floating",
      class: ["va-dropdown__content-wrapper", this.$props.contentClass],
      style: [this.floatingStyles, { zIndex: this.zIndex }],
      ...this.teleportedAttrs
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, slotBind, {
      ref: "anchorRef",
      role: this.$props.role,
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (typeof this.$props.cursor === "object" && floatingSlotNode) {
      return h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      );
    }
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      floatingSlotNode && h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaDropdown.vue_vue_type_script_lang.mjs.map
