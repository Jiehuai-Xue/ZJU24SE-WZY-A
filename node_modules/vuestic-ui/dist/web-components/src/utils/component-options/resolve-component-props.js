function normalizeProps(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m) => mergeProps(to, m, optionsType));
  const props = normalizeProps(from[optionsType]);
  for (const key in props) {
    to[key] = props[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  const mixins = options.mixins ?? [];
  const extendsOptions = options.extends ?? [];
  const result = {};
  mergeProps(result, extendsOptions, optionsType);
  for (let i = 0; i < mixins.length; i++) {
    mergeProps(result, mixins[i], optionsType);
  }
  Object.assign(result, normalizeProps(options[optionsType]));
  return result;
}
const getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};
export {
  getComponentProps as g
};
//# sourceMappingURL=resolve-component-props.js.map
