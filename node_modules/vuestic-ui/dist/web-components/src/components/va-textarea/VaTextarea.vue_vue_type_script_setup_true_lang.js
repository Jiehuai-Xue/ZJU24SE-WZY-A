import { defineComponent, shallowRef, computed, ref, watchEffect, openBlock, createBlock, unref, mergeProps, withCtx, createElementVNode, normalizeClass, withDirectives, isRef, vModelText } from "vue";
import { p as pick } from "../../../vendor.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { a as focusElement, b as blurElement } from "../../utils/focus.js";
import { u as useTextHeight } from "./composables/useLineHeight.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useFormFieldProps } from "../../composables/useFormField.js";
import { u as useStatefulProps, b as useStateful } from "../../composables/useStateful.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useEmitProxy } from "../../composables/useEmitProxy.js";
const _hoisted_1 = ["rows", "loading", "ariaLabel"];
const positiveNumberValidator = (val) => {
  if (val > 0) {
    return true;
  }
  throw new Error(
    `\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`
  );
};
const { createEmits, createListeners } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTextarea"
  },
  __name: "VaTextarea",
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: [Number, String],
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: [Number, String],
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits(), ...useValidationEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const textarea = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      isDirty,
      isTouched,
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props, emit, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed(() => {
      return props.resize && !props.autosize;
    });
    const rows = ref(props.minRows);
    const textHeight = useTextHeight(textarea, valueComputed);
    function calculateInputHeight() {
      let minRows = parseFloat(String(props.minRows));
      let maxRows = parseFloat(String(props.maxRows));
      minRows = isNaN(minRows) ? 1 : minRows;
      maxRows = isNaN(maxRows) ? Infinity : maxRows;
      if (!props.autosize) {
        rows.value = Math.max(maxRows, Math.min(minRows, maxRows ?? 0));
        return;
      }
      if (!textHeight.value || !textarea.value) {
        return;
      }
      const style = getComputedStyle(textarea.value);
      const height = textHeight.value;
      const lineHeight = parseFloat(style.lineHeight);
      const minHeight = Math.max(
        minRows * lineHeight,
        minRows + Math.round(lineHeight)
      );
      const maxHeight = maxRows * lineHeight || Infinity;
      const newHeight = Math.max(minHeight, Math.min(maxHeight, height ?? 0));
      rows.value = Math.round(newHeight / lineHeight);
      textarea.value.style.height = `${newHeight + 1}px`;
    }
    watchEffect(() => {
      calculateInputHeight();
    });
    const computedStyle = computed(
      () => ({
        resize: isResizable.value ? void 0 : "none"
      })
    );
    const computedProps = computed(() => ({
      ...pick(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps);
    const listeners = createListeners(emit);
    __expose({
      isDirty,
      isTouched,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps({ class: "va-textarea" }, unref(vaInputWrapperProps), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages)
      }), {
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass(["va-textarea__resize-wrapper", {
              "va-textarea__resize-wrapper--resizable": isResizable.value
            }])
          }, [
            withDirectives(createElementVNode("textarea", mergeProps({
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
            }, { ...computedProps.value, ...unref(listeners), ...unref(validationAriaAttributes), ...unref(validationListeners) }, {
              class: ["va-textarea__textarea", {
                "va-textarea__textarea--autosize": __props.autosize
              }],
              ref_key: "textarea",
              ref: textarea,
              rows: rows.value,
              style: computedStyle.value,
              loading: unref(isLoading),
              ariaLabel: _ctx.$props.label
            }), null, 16, _hoisted_1), [
              [vModelText, unref(valueComputed)]
            ])
          ], 2)
        ]),
        _: 1
      }, 16, ["error", "error-messages"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaTextarea.vue_vue_type_script_setup_true_lang.js.map
