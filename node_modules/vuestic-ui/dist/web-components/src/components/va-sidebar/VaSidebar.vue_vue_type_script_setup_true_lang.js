import { defineComponent, ref, computed, watchEffect, shallowRef, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, withDirectives, createElementVNode, createVNode, withCtx, renderSlot, vShow } from "vue";
import { u as useSidebar } from "./hooks/useSidebar.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useElementWidth } from "../../composables/useElementWidth.js";
import { _ as _sfc_main$1 } from "../va-config/VaConfig.vue_vue_type_script_setup_true_lang.js";
import { u as useColors } from "../../composables/useColors.js";
import { u as useTextColor } from "../../composables/useTextColor.js";
import { g as getGradientBackground } from "../../services/color/utils.js";
import { u as useBem } from "../../composables/useBem.js";
import { u as useClickOutside } from "../../composables/useClickOutside.js";
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSidebar"
  },
  __name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: [Number, String],
      default: 0.2,
      validator: (v) => Number(v) >= 0 && Number(v) <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: [Boolean, String], default: true },
    closeOnClickOutside: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const menu = ref();
    const currentMenuWidth = useElementWidth(menu);
    const doShowMenu = computed(() => {
      if (props.modelValue === true) {
        return true;
      }
      if (currentMenuWidth.value === null) {
        return true;
      }
      return currentMenuWidth.value > 0;
    });
    const sidebarWidth = ref();
    const getSidebarWidth = () => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    };
    const menuWidth = computed(() => isMinimized.value ? props.minimizedWidth : props.width);
    watchEffect(() => {
      const width = getSidebarWidth();
      setTimeout(() => {
        sidebarWidth.value = width;
      });
    });
    const backgroundColorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const backgroundColor = getColor(backgroundColorComputed.value);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0,
        overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
        width: sidebarWidth.value,
        minWidth: sidebarWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      animated: Boolean(props.animated),
      "animated-right": props.animated === "right",
      "animated-left": props.animated === "left" || props.animated === true
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    const rootElement = shallowRef();
    useClickOutside([rootElement], () => {
      if (props.closeOnClickOutside && props.modelValue) {
        setTimeout(() => {
          emit("update:modelValue", false);
        }, 0);
      }
    });
    const vaSidebarItemProps = computed(() => ({
      textColor: props.textColor,
      activeColor: props.activeColor,
      hoverColor: props.hoverColor,
      borderColor: props.borderColor,
      hoverOpacity: props.hoverOpacity
    }));
    __expose({
      isMinimized,
      isHovered,
      updateHoverState,
      rootElement,
      menu,
      doShowMenu,
      menuWidth,
      sidebarWidth
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("aside", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass(["va-sidebar", unref(computedClass)]),
        style: normalizeStyle(computedStyle.value),
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false))
      }, [
        withDirectives(createElementVNode("div", {
          class: "va-sidebar__menu",
          ref_key: "menu",
          ref: menu,
          style: normalizeStyle({
            width: menuWidth.value,
            minWidth: menuWidth.value
          })
        }, [
          createVNode(unref(_sfc_main$1), {
            components: { VaSidebarItem: vaSidebarItemProps.value }
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["components"])
        ], 4), [
          [vShow, doShowMenu.value]
        ])
      ], 38);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSidebar.vue_vue_type_script_setup_true_lang.js.map
