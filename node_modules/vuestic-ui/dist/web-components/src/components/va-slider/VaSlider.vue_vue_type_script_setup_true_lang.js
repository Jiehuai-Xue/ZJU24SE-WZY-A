import { defineComponent, shallowRef, ref, computed, useSlots, onMounted, onBeforeUnmount, watch, openBlock, createElementBlock, mergeProps, unref, renderSlot, createCommentVNode, normalizeStyle, createTextVNode, toDisplayString, createVNode, createElementVNode, Fragment, renderList, normalizeClass, normalizeProps, guardReactiveProps } from "vue";
import { p as pick } from "../../../vendor.js";
import { v as validateSlider } from "./validateSlider.js";
import { V as VaIcon } from "../va-icon/index.js";
import { u as useComponentUuid } from "../../composables/useComponentUuid.js";
import { u as useStatefulProps, b as useStateful } from "../../composables/useStateful.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useColors } from "../../composables/useColors.js";
import { u as useArrayRefs } from "../../composables/useArrayRefs.js";
import { u as useNumericProp } from "../../composables/useNumericProp.js";
import { u as useBem } from "../../composables/useBem.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
const _hoisted_1 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
const _hoisted_2 = ["id"];
const _hoisted_3 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
const _hoisted_4 = ["tabindex", "onFocus"];
const _hoisted_5 = ["tabindex"];
const _hoisted_6 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
const _hoisted_7 = ["id"];
const _hoisted_8 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSlider"
  },
  __name: "VaSlider",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String], default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true },
    ariaLabel: { type: String, default: "$t:sliderValue" }
  },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor, getHoverColor } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset = ref(0);
    const size = ref(0);
    const defaultValue = props.range ? [0, 100] : 0;
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue });
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const minComputed = useNumericProp("min");
    const maxComputed = useNumericProp("max");
    const stepComputed = useNumericProp("step");
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - stepComputed.value < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + stepComputed.value > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick(props, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = (val.value[0] - minComputed.value) / (maxComputed.value - minComputed.value) * 100;
        const val1 = (val.value[1] - minComputed.value) / (maxComputed.value - minComputed.value) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val0 = (val.value - minComputed.value) / (maxComputed.value - minComputed.value) * 100;
        return {
          [trackSizeStyle.value]: `${val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = (val.value[0] - minComputed.value) / (maxComputed.value - minComputed.value) * 100;
        const val1 = (val.value[1] - minComputed.value) / (maxComputed.value - minComputed.value) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val0 = (val.value - minComputed.value) / (maxComputed.value - minComputed.value) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => valueComputed.value,
      set: (val2) => {
        if (!flag.value) {
          emit("change", val2);
        }
        valueComputed.value = val2;
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (maxComputed.value - minComputed.value) / stepComputed.value;
      return size.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${stepComputed.value}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (maxComputed.value - minComputed.value) / stepComputed.value - 1);
    const position = computed(() => {
      return Array.isArray(val.value) ? [(val.value[0] - minComputed.value) / stepComputed.value * gap.value, (val.value[1] - minComputed.value) / stepComputed.value * gap.value] : (val.value - minComputed.value) / stepComputed.value * gap.value;
    });
    const limit = computed(() => [0, size.value]);
    const valueLimit = computed(() => [minComputed.value, maxComputed.value]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e, index = currentSliderDotIndex.value) => {
      var _a, _b;
      e.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e ? e.touches[0] : e;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(val.value)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(val.value) ? (_a = dots.value[index]) == null ? void 0 : _a.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e.preventDefault();
      if ("touches" in e) {
        setValueOnPos(getPos(e.touches[0]));
      } else {
        setValueOnPos(getPos(e));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", val.value);
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const clamp = (min, v, max) => Math.max(Math.min(v, max), min);
    const moveWithKeys = (event) => {
      var _a, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (where, which) => {
        if (Array.isArray(val.value)) {
          const value = val.value[which] + (where ? stepComputed.value : -stepComputed.value);
          const limitedValue = clamp(minComputed.value, value, maxComputed.value);
          val.value = [
            which === 0 ? limitedValue : val.value[0],
            which === 1 ? limitedValue : val.value[1]
          ];
        } else {
          const value = val.value + (where ? stepComputed.value : -stepComputed.value);
          const limitedValue = clamp(minComputed.value, value, maxComputed.value);
          val.value = limitedValue;
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== minComputed.value):
            (_a = dots.value[0]) == null ? void 0 : _a.focus();
            moveDot(0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== maxComputed.value):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== minComputed.value):
            moveDot(0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== maxComputed.value):
            moveDot(1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== minComputed.value):
            moveDot(0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== maxComputed.value):
            moveDot(1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * stepComputed.value > val.value[0] && pin * stepComputed.value < val.value[1];
      } else {
        return pin * stepComputed.value < val.value;
      }
    };
    const pinPositionStep = computed(() => stepComputed.value / (maxComputed.value - minComputed.value) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e) => {
      getStaticData();
      return props.vertical ? offset.value - e.clientY : e.clientX - offset.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (stepComputed.value * multiple.value * index + minComputed.value * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value)) {
        if (isDiff(val.value[slider], newValue)) {
          if (slider === 0) {
            val.value = [newValue, val.value[1]];
          } else {
            val.value = [val.value[0], newValue];
          }
        }
      } else {
        if (newValue < minComputed.value) {
          val.value = minComputed.value;
        } else if (newValue > maxComputed.value) {
          val.value = maxComputed.value;
        } else if (isDiff(val.value, newValue)) {
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(val.value) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        const v = getValueByIndex(Math.round(pixelPosition / gap.value));
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value = [v, val.value[0]];
            currentSliderDotIndex.value = 0;
          } else {
            setCurrentValue(v);
          }
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value = [val.value[1], v];
            currentSliderDotIndex.value = 1;
          } else {
            setCurrentValue(v);
          }
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
    const clickOnContainer = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const componentId = useComponentUuid();
    const ariaLabelIdComputed = computed(() => `aria-label-id-${componentId}`);
    const { tp } = useTranslation();
    const slots = useSlots();
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": minComputed.value,
      "aria-valuemax": maxComputed.value,
      "aria-label": !slots.label && !props.label ? tp(props.ariaLabel, { value: String(val.value) }) : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      "aria-orientation": props.vertical ? "vertical" : "horizontal",
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(val.value) ? val.value : void 0,
      "aria-valuetext": Array.isArray(val.value) ? String(val.value) : void 0
    }));
    onMounted(() => {
      if (validateSlider(val.value, stepComputed.value, minComputed.value, maxComputed.value, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => stepComputed.value,
      () => minComputed.value,
      () => maxComputed.value,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value, step, min, max, range);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-slider", unref(sliderClass)]
      }, ariaAttributesComputed.value), [
        (__props.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_1, [
          renderSlot(_ctx.$slots, __props.vertical ? "append" : "prepend")
        ])) : createCommentVNode("", true),
        (_ctx.$slots.label || __props.label) && !__props.invertLabel ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "va-input__label",
          id: ariaLabelIdComputed.value,
          style: normalizeStyle(labelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 12, _hoisted_2)) : createCommentVNode("", true),
        (__props.vertical ? __props.iconAppend : __props.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_3, [
          createVNode(unref(VaIcon), {
            name: __props.vertical ? __props.iconAppend : __props.iconPrepend,
            color: unref(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode("", true),
        createElementVNode("div", {
          ref_key: "sliderContainer",
          ref: sliderContainer,
          class: "va-slider__container",
          onMousedown: clickOnContainer,
          onTouchstart: clickOnContainer
        }, [
          createElementVNode("div", {
            class: "va-slider__track",
            "aria-hidden": "true",
            style: normalizeStyle(trackStyles.value)
          }, null, 4),
          __props.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(pinsCol.value, (pin, i) => {
            return openBlock(), createElementBlock("div", {
              key: i,
              class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": checkActivePin(pin) }]),
              style: normalizeStyle(getPinStyles(pin))
            }, null, 6);
          }), 128)) : createCommentVNode("", true),
          _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createElementVNode("div", {
              ref: "process",
              class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              "aria-hidden": "true",
              style: normalizeStyle(processedStyles.value)
            }, null, 6),
            (openBlock(true), createElementBlock(Fragment, null, renderList(orders.value, (order) => {
              return openBlock(), createElementBlock("div", {
                key: "dot" + order,
                ref_for: true,
                ref: unref(setItemRefByIndex)(order),
                class: normalizeClass(["va-slider__handler", unref(dotClass)]),
                style: normalizeStyle(getDottedStyles(order)),
                tabindex: __props.disabled || __props.readonly ? void 0 : 0,
                onFocus: ($event) => (isFocused.value = true, currentSliderDotIndex.value = order),
                onBlur: _cache[0] || (_cache[0] = ($event) => isFocused.value = false)
              }, [
                isActiveDot(order) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  style: normalizeStyle({ backgroundColor: unref(getColor)(_ctx.$props.color) }),
                  class: "va-slider__handler__dot--focus"
                }, null, 4)) : createCommentVNode("", true),
                __props.trackLabelVisible ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  style: normalizeStyle(labelStyles.value),
                  class: "va-slider__handler__dot--value"
                }, [
                  renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: getValueByOrder(order), order })), () => [
                    createTextVNode(toDisplayString(getTrackLabel(getValueByOrder(order), order)), 1)
                  ])
                ], 4)) : createCommentVNode("", true)
              ], 46, _hoisted_4);
            }), 128))
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createElementVNode("div", {
              ref: "process",
              "aria-hidden": "true",
              class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              style: normalizeStyle(processedStyles.value)
            }, null, 6),
            createElementVNode("div", {
              ref_key: "dot",
              ref: dot,
              class: normalizeClass(["va-slider__handler", unref(dotClass)]),
              style: normalizeStyle(dottedStyles.value),
              tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
              onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = true),
              onBlur: _cache[2] || (_cache[2] = ($event) => isFocused.value = false)
            }, [
              isActiveDot(0) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-slider__handler__dot--focus",
                style: normalizeStyle({ backgroundColor: unref(getColor)(_ctx.$props.color) })
              }, null, 4)) : createCommentVNode("", true),
              __props.trackLabelVisible ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "va-slider__handler__dot--value",
                style: normalizeStyle(labelStyles.value)
              }, [
                renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: getValueByOrder() })), () => [
                  createTextVNode(toDisplayString(getTrackLabel(getValueByOrder())), 1)
                ])
              ], 4)) : createCommentVNode("", true)
            ], 46, _hoisted_5)
          ], 64))
        ], 544),
        (__props.vertical ? __props.iconPrepend : __props.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_6, [
          createVNode(unref(VaIcon), {
            name: __props.vertical ? __props.iconPrepend : __props.iconAppend,
            color: unref(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode("", true),
        (_ctx.$slots.label || __props.label) && __props.invertLabel ? (openBlock(), createElementBlock("span", {
          key: 4,
          class: "va-input__label va-input__label--inverse",
          style: normalizeStyle(labelStyles.value),
          id: ariaLabelIdComputed.value
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 12, _hoisted_7)) : createCommentVNode("", true),
        (__props.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_8, [
          renderSlot(_ctx.$slots, __props.vertical ? "prepend" : "append")
        ])) : createCommentVNode("", true)
      ], 16);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSlider.vue_vue_type_script_setup_true_lang.js.map
