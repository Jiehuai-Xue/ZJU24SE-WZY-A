import { defineComponent, shallowRef, computed, watch, ref, nextTick, useSlots, openBlock, createBlock, unref, mergeProps, withCtx, createVNode, createSlots, withModifiers, withKeys, createCommentVNode, renderList, renderSlot, normalizeProps, guardReactiveProps, normalizeStyle, isRef } from "vue";
import { p as pick } from "../../../vendor.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaSelectOptionList } from "./components/VaSelectOptionList/index.js";
import { V as VaSelectContent } from "./components/VaSelectContent/index.js";
import { u as useMaxVisibleOptionsProps, a as useMaxVisibleOptions } from "./hooks/useMaxVisibleOptions.js";
import { u as useToggleIconProps, a as useToggleIcon } from "./hooks/useToggleIcon.js";
import { u as useStringValueProps, a as useStringValue } from "./hooks/useStringValue.js";
import { u as useAutocompleteProps, a as useAutocomplete } from "./hooks/useAutocomplete.js";
import { u as useSelectAria } from "./hooks/useSelectAria.js";
import { a as focusElement, b as blurElement } from "../../utils/focus.js";
import { u as unwrapEl } from "../../utils/unwrapEl.js";
import { i as isNilValue } from "../../utils/isNilValue.js";
import { w as warn } from "../../utils/console.js";
import { u as useMaxSelectionsProps, a as useMaxSelections } from "../../composables/useMaxSelections.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { u as useLoadingProps } from "../../composables/useLoading.js";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.js";
import { u as useFormFieldProps } from "../../composables/useFormField.js";
import { u as useThrottleProps } from "../../composables/useThrottle.js";
import { u as useDropdownableProps, a as useDropdownableEmits, b as useDropdownable } from "../../composables/useDropdownable.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
import { u as useFocusDeep } from "../../composables/useFocusDeep.js";
import { u as useSyncProp } from "../../composables/useSyncProp.js";
import { u as useNumericProp } from "../../composables/useNumericProp.js";
import { u as useBem } from "../../composables/useBem.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelect"
  },
  __name: "VaSelect",
  props: {
    ...VaInputWrapperProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormFieldProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    ...useDropdownableProps,
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: void 0
    },
    // Dropdown placement
    placement: { ...useDropdownableProps.placement, default: "bottom" },
    keepAnchorWidth: { ...useDropdownableProps.keepAnchorWidth, default: true },
    offset: { ...useDropdownableProps.offset, default: [1, 0] },
    closeOnContentClick: { ...useDropdownableProps.closeOnContentClick, default: false },
    trigger: { ...useDropdownableProps.trigger, default: () => ["click", "right-click", "space", "enter"] },
    // Select options
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: [Number, String], default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    // Input style
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    ariaLabel: { type: String, default: "$t:select" },
    ariaSearchLabel: { type: String, default: "$t:optionsFilter" },
    ariaClearLabel: { type: String, default: "$t:reset" },
    search: { type: String, default: void 0 }
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    "update:search",
    ...useDropdownableEmits,
    ...useValidationEmits,
    ...useClearableEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { tp, t } = useTranslation();
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getValue, getText, getTrackBy, tryResolveByValue } = useSelectableList(props);
    const getValueText = (option) => getText(tryResolveByValue(option));
    const onScrollBottom = () => emit("scroll-bottom");
    const [searchVModel] = useSyncProp("search", props, emit, "");
    const showSearchInput = computed(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch(searchVModel, (value) => {
      emit("update-search", value);
      if (!props.autocomplete) {
        hoveredOption.value = null;
      }
    });
    const getOptionByValue = (value) => {
      if (isNilValue(value) || typeof value === "object") {
        return value;
      }
      const optionByValue = props.options.find((option) => value === getValue(option));
      if (optionByValue === void 0) {
        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`);
        return value;
      }
      return optionByValue;
    };
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props, getOptionByValue);
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string, number, boolean or an object for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(option) {
        if (Array.isArray(option)) {
          emit("update:modelValue", option.map(getValue));
        } else {
          emit("update:modelValue", getValue(option));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getValueText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const normalizedOptionValue = computed(() => {
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => tryResolveByValue(value));
      }
      return tryResolveByValue(valueComputed.value);
    });
    const checkIsOptionSelected = (option) => {
      if (Array.isArray(normalizedOptionValue.value)) {
        return !isNilValue(normalizedOptionValue.value.find((valueItem) => compareOptions(valueItem, option)));
      }
      return compareOptions(normalizedOptionValue.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue(option1);
      const two = getValue(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchVModel.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(option);
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = option;
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => [searchVModel.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchVModel.value || autocompleteValue.value);
        searchVModel.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!isOpenSync.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusNextOption();
    };
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => !props.multiple)
    });
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    const showDropdownContentComputed = computed({
      get: () => isOpenSync.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      isOpenSync.value = false;
      if (!props.autocomplete) {
        searchVModel.value = "";
      }
      nextTick(() => {
        validate();
        isInputFocused.focusIfNothingIfFocused();
      });
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = async () => {
      await nextTick();
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      validationListeners.onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const openSelectButtonTabIndexComputed = computed(() => props.disabled || props.autocomplete ? -1 : 0);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchVModel.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const optionsListPropsComputed = computed(() => ({
      ...pick(props, ["textBy", "trackBy", "groupBy", "valueBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "delay", "selectedTopShown"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchVModel.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText),
      doShowAllOptions: doShowAllOptions.value,
      minSearchChars: minSearchCharsComputed.value
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, isOpenSync);
    const isFocused = computed(() => isInputFocused.value || isOpenSync.value);
    const slots = useSlots();
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps);
    const inputWrapperPropsComputed = computed(() => ({
      ...vaInputWrapperProps.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      "aria-label": props.ariaLabel || (props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption"))
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick(props, ["placeholder", "autocomplete", "multiple", "disabled", "readonly"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText: getValueText
    }));
    const autocompleteValue = useAutocomplete(searchVModel, props, visibleSelectedOptions, isOpenSync, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const doShowAllOptions = ref(true);
    watch(showDropdownContentComputed, () => {
      doShowAllOptions.value = true;
    });
    watch(searchVModel, () => {
      doShowAllOptions.value = false;
    });
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchVModel.value = "";
      emit("clear");
      resetValidation();
      nextTick(() => {
        isInputFocused.value = true;
      });
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete && !props.disabled && !props.readonly) {
        e == null ? void 0 : e.stopImmediatePropagation();
        isInputFocused.value = true;
        isOpenSync.value = true;
      }
    };
    const toggleDropdown = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const isInInput = e.target && "tagName" in e.target && e.target.tagName === "INPUT";
      if (e.code === "Space" && isInInput) {
        return;
      }
      e.preventDefault();
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation,
      validationAriaAttributes,
      listeners: validationListeners,
      isTouched
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    watch(isOpenSync, (isOpen) => {
      if (!isOpen) {
        isTouched.value = true;
      }
    });
    const { popupId } = useSelectAria();
    const searchInput = searchVModel;
    const onInputFocus = onFocus;
    __expose({
      focus,
      blur,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps({
        ref: "dropdown",
        modelValue: showDropdownContentComputed.value,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => showDropdownContentComputed.value = $event),
        class: "va-select va-select__dropdown va-select-dropdown"
      }, dropdownPropsComputed.value, {
        role: "combobox",
        "inner-anchor-selector": ".va-input-wrapper__field",
        "keyboard-navigation": false
      }), {
        anchor: withCtx(() => [
          createVNode(unref(VaInputWrapper), mergeProps(inputWrapperPropsComputed.value, {
            ref_key: "input",
            ref: input,
            class: ["va-select__anchor va-select-anchor__input", unref(inputWrapperClassComputed)],
            "aria-haspopup": "listbox",
            "model-value": unref(valueString),
            readonly: true,
            "aria-label": _ctx.$props.ariaLabel,
            "aria-controls": unref(popupId),
            "aria-owns": unref(popupId),
            onFocus: unref(onInputFocus),
            onBlur: onInputBlur
          }), createSlots({
            icon: withCtx(() => [
              showClearIcon.value ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                role: "button",
                "aria-label": unref(tp)(_ctx.$props.ariaClearLabel)
              }, unref(clearIconProps), {
                onClick: withModifiers(reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true)
            ]),
            appendInner: withCtx(() => [
              createVNode(unref(VaIcon), {
                color: unref(toggleIconColor),
                name: unref(toggleIcon),
                class: "va-select__toggle-icon",
                role: "button",
                tabindex: openSelectButtonTabIndexComputed.value,
                "aria-expanded": showDropdownContentComputed.value,
                onKeydown: withKeys(toggleDropdown, ["enter"])
              }, null, 8, ["color", "name", "tabindex", "aria-expanded"])
            ]),
            default: withCtx(({ ariaAttributes }) => [
              createVNode(unref(VaSelectContent), mergeProps(selectContentPropsComputed.value, {
                ariaAttributes,
                separator: _ctx.$props.separator,
                onToggleHidden: unref(toggleHiddenOptionsState),
                onAutocompleteInput: setAutocompleteValue,
                onFocusPrev: focusPreviousOption,
                onFocusNext: focusNextOption,
                onSelectOption: selectOrAddOption,
                onDeleteLastSelected: deleteLastSelected
              }), createSlots({ _: 2 }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((slotScope) => [
                      renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                    ])
                  };
                })
              ]), 1040, ["ariaAttributes", "separator", "onToggleHidden"])
            ]),
            _: 2
          }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["class", "model-value", "aria-label", "aria-controls", "aria-owns", "onFocus"])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            class: "va-select-dropdown__content",
            style: normalizeStyle({ width: _ctx.$props.width }),
            onKeydown: withKeys(hideAndFocus, ["esc"]),
            role: "dialog"
          }, {
            default: withCtx(() => [
              showSearchInput.value ? (openBlock(), createBlock(unref(VaInputWrapper), {
                key: 0,
                ref_key: "searchBar",
                ref: searchBar,
                class: "va-select-dropdown__content-search-input",
                modelValue: unref(searchInput),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(searchInput) ? searchInput.value = $event : null),
                "aria-label": unref(tp)(_ctx.$props.ariaSearchLabel),
                tabindex: tabIndexComputed.value,
                placeholder: unref(tp)(_ctx.$props.searchPlaceholderText),
                preset: "bordered",
                onKeydown: [
                  withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["up"]),
                  withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["left"]),
                  withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["down"]),
                  withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["right"]),
                  withKeys(withModifiers(selectOrAddOption, ["prevent"]), ["enter"])
                ],
                onFocus: _cache[1] || (_cache[1] = ($event) => hoveredOption.value = null)
              }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode("", true),
              createVNode(unref(VaSelectOptionList), mergeProps({
                ref_key: "optionList",
                ref: optionList,
                class: "va-select-dropdown__options-wrapper",
                hoveredOption: hoveredOption.value,
                "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => hoveredOption.value = $event),
                style: { maxHeight: _ctx.$props.maxHeight },
                id: unref(popupId)
              }, optionsListPropsComputed.value, {
                onSelectOption: selectHoveredOption,
                onNoPreviousOptionToHover: focusSearchBar,
                onKeydown: [
                  _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => searchBar.value && searchBar.value.focus(), ["stop", "prevent"]), ["tab"])),
                  onHintedSearch
                ],
                onScrollBottom
              }), {
                default: withCtx((slotData) => [
                  renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData)))
                ]),
                "option-content": withCtx((slotData) => [
                  renderSlot(_ctx.$slots, "option-content", normalizeProps(guardReactiveProps(slotData)))
                ]),
                _: 3
              }, 16, ["hoveredOption", "style", "id"])
            ]),
            _: 3
          }, 8, ["style"])
        ]),
        _: 3
      }, 16, ["modelValue"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSelect.vue_vue_type_script_setup_true_lang.js.map
