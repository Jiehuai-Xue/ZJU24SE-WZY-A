import { defineComponent, shallowRef, computed, nextTick, watch, useSlots, useAttrs, openBlock, createBlock, unref, mergeProps, withCtx, createVNode, createSlots, withModifiers, withKeys, createCommentVNode, renderList, renderSlot, normalizeProps, guardReactiveProps, isRef } from "vue";
import { u as useTimeParser } from "./hooks/time-text-parser.js";
import { u as useTimeFormatter } from "./hooks/time-text-formatter.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { _ as _VaTimePicker } from "../va-time-picker/VaTimePicker.js";
import { u as useLongPressKey } from "../../composables/useLongPresKey.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useDropdownableProps, a as useDropdownableEmits, b as useDropdownable } from "../../composables/useDropdownable.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { u as useStatefulProps, a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
import { a as useFocusEmits, u as useFocus } from "../../composables/useFocus.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTimeInput",
    inheritAttrs: false
  },
  __name: "VaTimeInput",
  props: {
    ...VaInputWrapperProps,
    ...useDropdownableProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...extractComponentProps(_VaTimePicker),
    ...useValidationProps,
    ...useStatefulProps,
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    placement: { ...useDropdownableProps.placement, default: "bottom-end" },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: null },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" },
    ariaLabel: { type: String, default: "$t:selectedTime" },
    ariaResetLabel: { type: String, default: "$t:resetTime" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" }
  },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef();
    const timePicker = shallowRef();
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => Array.isArray(props.view) && props.view.length === 1)
    });
    const { valueComputed } = useStateful(props, emit);
    const { parse, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(valueComputed.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a;
      if (props.disabled) {
        return;
      }
      const val = (_a = e.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v = parse(val);
      if (isValid.value && v) {
        valueComputed.value = v;
      } else {
        valueComputed.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
      hideDropdown();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation,
      isDirty,
      isTouched
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    watch(doShowDropdown, (v) => {
      if (!v) {
        isTouched.value = true;
      }
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput,
      modelValue: valueText.value
    }));
    const viewToNumber = {
      seconds: 1e3,
      minutes: 1e3 * 60,
      hours: 1e3 * 60 * 60
    };
    const onKeyPress = (e) => {
      if (!("key" in e)) {
        return;
      }
      if (e.key === "ArrowDown") {
        valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props.view]);
        e.preventDefault();
      }
      if (e.key === "ArrowUp") {
        valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props.view]);
        e.preventDefault();
      }
    };
    useLongPressKey(input, {
      onStart: onKeyPress,
      onUpdate: onKeyPress
    });
    const computedInputListeners = {
      onFocus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
      },
      onBlur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    };
    const slots = useSlots();
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const { tp } = useTranslation();
    useAttrs();
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "space", "enter"]
    }));
    const timePickerProps = filterComponentProps(extractComponentProps(_VaTimePicker));
    __expose({
      isFocused,
      isValid,
      value: valueComputed,
      isDirty,
      isTouched,
      focus,
      blur,
      reset,
      withoutValidation,
      resetValidation,
      toggleDropdown,
      showDropdown,
      hideDropdown
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps({
        modelValue: doShowDropdown.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => doShowDropdown.value = $event),
        class: ["va-time-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value), {
        anchor: withCtx(() => [
          createVNode(unref(VaInputWrapper), mergeProps({
            class: "va-time-input__anchor",
            ref_key: "input",
            ref: input,
            style: cursorStyleComputed.value
          }, { ...computedInputWrapperProps.value, ...unref(validationAriaAttributes), ...computedInputListeners }, { onChange: onInputTextChanged }), createSlots({
            icon: withCtx(() => [
              canBeClearedComputed.value ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                class: "va-time-input__clear-button"
              }, { ...iconProps.value, ...unref(clearIconProps) }, {
                "aria-label": unref(tp)(_ctx.$props.ariaResetLabel),
                onClick: withModifiers(reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
              !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 1,
                class: "va-time-input__right-button va-time-input__side-button",
                "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
              }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
            ]),
            _: 2
          }, [
            renderList(filteredSlots.value, (name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref(isOpenSync), focus: unref(focus) })))
                ])
              };
            }),
            _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
              name: "prependInner",
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref(isOpenSync), focus: unref(focus) }))),
                _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                  key: 0,
                  class: "va-time-input__left-button va-time-input__side-button",
                  "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["style"])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            "no-padding": "",
            onKeydown: [
              withKeys(withModifiers(hideDropdown, ["prevent"]), ["esc"]),
              withKeys(withModifiers(hideDropdown, ["prevent"]), ["enter"])
            ]
          }, {
            default: withCtx(() => [
              createVNode(_VaTimePicker, mergeProps({
                ref_key: "timePicker",
                ref: timePicker
              }, unref(timePickerProps), {
                modelValue: unref(valueComputed),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
              }), null, 16, ["modelValue"])
            ]),
            _: 1
          }, 8, ["onKeydown"])
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaTimeInput.vue_vue_type_script_setup_true_lang.js.map
