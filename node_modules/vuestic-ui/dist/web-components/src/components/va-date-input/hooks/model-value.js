import { i as isNil } from "../../../../vendor.js";
import { computed } from "vue";
import { f as formatDateToTheSameStandardFormat } from "../utils/parse-date.js";
const isRange = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};
const isMultiple = (date) => {
  if (date === null) {
    return false;
  }
  return Array.isArray(date);
};
const isSingleDate = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "string" || typeof date === "number" || date instanceof Date;
};
const useDateInputModelValue = (modelValue, mode, parseModelValue, formatModelValue, formatModelValueSingleDate) => {
  const syncFormat = (original, target) => {
    if (formatModelValueSingleDate) {
      return formatModelValueSingleDate(target);
    }
    if (typeof original === "string") {
      const standardFormat = formatDateToTheSameStandardFormat(target, original);
      if (standardFormat) {
        return standardFormat;
      }
      return formatModelValue(target);
    }
    if (typeof original === "number") {
      return target.getTime();
    }
    return target;
  };
  const normalizeSingleDate = (value) => {
    if (value instanceof Date) {
      return value;
    }
    return new Date(value);
  };
  const dateValue = computed(() => {
    if (modelValue.value === null || modelValue.value === void 0) {
      return null;
    }
    if (typeof modelValue.value === "string") {
      return parseModelValue(modelValue.value);
    }
    if (typeof modelValue.value === "number") {
      return new Date(modelValue.value);
    }
    return modelValue.value;
  });
  const normalized = computed({
    get: () => {
      if (dateValue.value === null || dateValue.value === void 0) {
        return null;
      }
      if (isMultiple(dateValue.value)) {
        return dateValue.value.map(normalizeSingleDate);
      }
      if (isRange(dateValue.value)) {
        const { start, end } = dateValue.value;
        return {
          start: start ? normalizeSingleDate(start) : null,
          end: end ? normalizeSingleDate(end) : null
        };
      }
      return normalizeSingleDate(dateValue.value);
    },
    set(newValue) {
      var _a, _b;
      if (newValue === null || newValue === void 0) {
        modelValue.value = newValue;
        return;
      }
      if (isMultiple(newValue) && (isMultiple(modelValue.value) || isNil(modelValue.value))) {
        const originalValue = modelValue.value;
        modelValue.value = newValue.map((v, index) => syncFormat((originalValue == null ? void 0 : originalValue[index]) || (originalValue == null ? void 0 : originalValue[0]), v));
        return;
      }
      if (isRange(newValue) && (isRange(modelValue.value) || isNil(modelValue.value))) {
        const { start, end } = newValue;
        modelValue.value = {
          start: start ? syncFormat((_a = modelValue.value) == null ? void 0 : _a.start, start) : null,
          // Sync end date only if start date is specified
          end: end ? syncFormat((_b = modelValue.value) == null ? void 0 : _b.start, end) : null
        };
        return;
      }
      if (isSingleDate(newValue) && (isSingleDate(modelValue.value) || isNil(modelValue.value))) {
        modelValue.value = syncFormat(modelValue.value, newValue);
        return;
      }
      console.log({ inputDate: newValue, modelValue: modelValue.value });
      throw new Error("Input date is not the same as date from props");
    }
  });
  const text = computed({
    get: () => {
      if (normalized.value === null || normalized.value === void 0) {
        return "";
      }
      return formatModelValue(normalized.value);
    },
    set: (value) => {
      modelValue.value = parseModelValue(value);
    }
  });
  return {
    text,
    normalized
  };
};
export {
  useDateInputModelValue as u
};
//# sourceMappingURL=model-value.js.map
