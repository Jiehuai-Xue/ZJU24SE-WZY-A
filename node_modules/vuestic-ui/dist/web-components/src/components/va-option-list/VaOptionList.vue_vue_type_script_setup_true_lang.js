import { defineComponent, computed, onMounted, openBlock, createBlock, unref, withCtx, createElementVNode, createElementBlock, Fragment, renderList, renderSlot, normalizeProps, guardReactiveProps, mergeProps } from "vue";
import { p as pick } from "../../../vendor.js";
import { i as isDev } from "../../utils/env.js";
import { V as VaCheckbox } from "../va-checkbox/index.js";
import { V as VaRadio } from "../va-radio/index.js";
import { V as VaSwitch } from "../va-switch/index.js";
import { u as useArrayRefs } from "../../composables/useArrayRefs.js";
import { V as VaMessageListWrapper } from "../va-message-list/VaMessageListWrapper.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { u as useStatefulProps, a as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
const _hoisted_1 = { class: "va-option-list__list" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaOptionList"
  },
  __name: "VaOptionList",
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Boolean, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Boolean, Object, Array] }
  },
  emits: [...useStatefulEmits, ...useValidationEmits, "clear"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: props.defaultValue });
    const { getValue, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue) : [value ? getValue(value) : value];
        }
      }
    });
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const computedProps = computed(() => pick(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (isDev && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    __expose({
      focus,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaMessageListWrapper), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx(() => [
          createElementVNode("ul", _hoisted_1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
              return openBlock(), createElementBlock("li", {
                key: unref(getTrackBy)(option)
              }, [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: selectedValue.value, isDisabled, getText: unref(getText), getValue: unref(getValue) })), () => [
                  _ctx.$props.type === "radio" ? (openBlock(), createBlock(unref(VaRadio), mergeProps({
                    key: 0,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    option: unref(getValue)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(unref(VaCheckbox), mergeProps({
                    key: 1,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref(getValue)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(unref(VaSwitch), mergeProps({
                    key: 2,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref(getValue)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"]))
                ])
              ]);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["error", "error-messages", "error-count"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaOptionList.vue_vue_type_script_setup_true_lang.js.map
