import { defineComponent, computed, openBlock, createBlock, unref, mergeProps, withCtx, createElementBlock, Fragment, renderList, createTextVNode, toDisplayString } from "vue";
import { V as VaButton } from "../va-button/index.js";
import { V as VaButtonGroup } from "../va-button-group/index.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { u as useColors } from "../../composables/useColors.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
const VaButtonGroupProps = extractComponentProps(VaButtonGroup);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaButtonToggle"
  },
  __name: "VaButtonToggle",
  props: {
    ...VaButtonGroupProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: { type: [String, Number, Boolean], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" },
    textBy: { type: [String, Function], default: "label" },
    valueBy: { type: [String, Function], default: "value" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getText, getTrackBy } = useSelectableList(props);
    const { getColor, shiftHSLAColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isToggled = (value) => getTrackBy(value) === props.modelValue;
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      }
      return shiftHSLAColor(colorComputed.value, { l: props.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed(() => {
      if (!props.preset || props.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props.pressedOpacity };
    });
    const activeButtonPropsComputed = computed(() => ({
      color: activeButtonColor.value,
      textColor: props.activeButtonTextColor,
      ...activeButtonBackgroundOpacityComputed.value
    }));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option)) {
        return iconsProps;
      }
      return {
        ...isToggled(option) && activeButtonPropsComputed.value,
        ...iconsProps
      };
    };
    const buttonGroupPropsComputed = filterComponentProps(VaButtonGroupProps);
    const changeValue = (value) => emit("update:modelValue", getTrackBy(value));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaButtonGroup), mergeProps({ class: "va-button-toggle" }, unref(buttonGroupPropsComputed)), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (option) => {
            return openBlock(), createBlock(unref(VaButton), mergeProps({
              key: unref(getTrackBy)(option),
              "aria-pressed": isToggled(option)
            }, getButtonProps(option), {
              onClick: ($event) => changeValue(option)
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(getText)(option)), 1)
              ]),
              _: 2
            }, 1040, ["aria-pressed", "onClick"]);
          }), 128))
        ]),
        _: 1
      }, 16);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaButtonToggle.vue_vue_type_script_setup_true_lang.js.map
